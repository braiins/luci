<%#
 Copyright 2010 Jo-Philipp Wich <jow@openwrt.org>
 Licensed to the public under the Apache License 2.0.
-%>

<%+header%>

<script type="text/javascript" src="<%=resource%>/cbi.js?v=git-18.296.46953-d87b0c8"></script>

	<style>
table.clean { width: auto; border: none; padding: 0; }
table.clean td { width: auto; border: none; padding: 0 2em 0 0; }
table.stats td { border: 1px solid black !important; padding: 4px; min-width: 5em; text-align: center; }
table.stats th { border: none; text-align: center; font-weight: bold; }
a { text-decoration: none; }
table.stats { width: auto; margin-top: 1en; border: none; }
.highlighted { background-color: #ddd; }

	</style>

<h1>Miner Status<span id="what"></span></h1>
<p>API connection status: <span id="status">Connecting...</span></p>

<embed id="hashrate-svg" style="width:100%; height:300px; border:1px solid #000000; background-color:#FFFFFF" src="/luci-static/resources/miner_graph.svg">

<table class="stats" id="chains-table"></table>
<table class="stats" id="pools-table"></table>
<table class="stats" id="summary-table"></table>
<table class="clean"><tr>
<td>
	<table class="stats" id="fanctrl-table"></table>
</td>
<td>
	<table class="stats" id="fans-table"></table>
</td>
</tr></table>

<script type="text/javascript">//<![CDATA[

/*
 * "Constants"
 */

/* must match SVG */
var MAX_GRAPHS = 3;
var PAGE_TICK_DURATION_MS = 1000;
var PAGE_DEAD_TIMEOUT_MS = 5000;
var API_PORT = 4028;
/* draw last ... seconds of history */
var DRAW_HISTORY_SEC = 5 * 60;
var SAMPLING_FREQ = 1 / (PAGE_TICK_DURATION_MS / 1000);
var KEEP_HISTORY_SEC = DRAW_HISTORY_SEC * 1.2;


/*
 * Utility functions
 */

function mod0(x, y) {
	return (x % y + y) % y;
}
function defaultNaN(x, def) {
	return isNaN(x) ? def : x;
}
function minNaN(x, y) {
	if (isNaN(x))
		return y;
	if (isNaN(y))
		return x;
	return Math.min(x, y);
}
function maxNaN(x, y) {
	if (isNaN(x))
		return y;
	if (isNaN(y))
		return x;
	return Math.max(x, y);
}

function listMax(list) {
	var max = list[0];
	for (i in list) {
		max = Math.max(max, list[i]);
	}
	return max;
}
function listMin(list) {
	var min = list[0];
	for (i in list) {
		min = Math.min(min, list[i]);
	}
	return min;
}
function listSum(list) {
	var sum = 0;
	for (i in list) {
		sum += list[i];
	}
	return sum;
}
function listAvg(list) {
	var len = list.length;
	if (len == 0)
		return 0;
	return listSum(list) / len;
}
function pickKey(list, key)
{
	var out = [];
	for (x in list)
		out.push(list[x][key]);
	return out;
}
function range(a, b)
{
	var t = [];
	for (var i = a; i < b; i++)
		t.push(i);
	return t;
}

function lookupByKey(table, key, value)
{
	for (i in table) {
		if (table[i][key] == value)
			return table[i];
	}
	return null;
}

function zeroPad(num, places)
{
  var zero = places - num.toString().length + 1;
  return Array(+(zero > 0 && zero)).join("0") + num;
}

/*
 * Scheduler class (via closures)
 */

function Scheduler(callback, timeout)
{
	var run;
	run = function () {
		setTimeout(run, timeout);
		callback();
	};
	return {
		run: run
	};
}

/*
 * Dataset class (via prototypes)
 */

function Dataset(samplingFreq, secondsOfHistory)
{
	this.samplingFreq = samplingFreq;
	/* At 2Hz sampling rate and 4 seconds you needs 2*4 = 8 samples */
	this.totalSamples = secondsOfHistory * samplingFreq;
	/* Data is "ring buffer" */
	this.data = [];
	/* "n" is pointer to ring buffer */
	this.n = 0;
	/* last sample to fill-in for missing samples */
	this.last = 0;
	this.resetCounter();
}

Dataset.prototype.resetCounter = function ()
{
	/* computed min/max/avg since last reset */
	this.countMax = NaN;
	this.countMin = NaN;
	this.countAvgSum = 0;
	this.countAvgN = 0;
};

Dataset.prototype.push = function (sample)
{
	this.data[this.n] = sample;
	this.n += 1;
	if (this.n >= this.totalSamples)
		this.n = 0;
	this.last = sample;
	/* compute avg */
	this.countAvgSum += sample;
	this.countAvgN++;
	this.countMin = minNaN(this.countMin, sample);
	this.countMax = maxNaN(this.countMax, sample);
};

Dataset.prototype.pushLast = function ()
{
	this.push(this.last);
};

Dataset.prototype.getStatsStr = function ()
{
	if (this.countAvgN == 0)
		return "not yet";
	var avg = this.countAvgSum / this.countAvgN;
	return 'Avg: ' + avg.toFixed(2) +
		' Min: ' + this.countMin.toFixed(2) +
		' Max: ' + this.countMax.toFixed(2)
}

Dataset.prototype.getBundle = function (nSeconds)
{
	var nSamples = this.samplingFreq * nSeconds;
	var ret = [];
	var first = true;
	/*
         * min and max gets overwritten in first iteration with some real
         * value. the only case "NaN" is returned is when the returned
         * dataSet is empty.
         */
	var max = NaN, min = NaN;
	var len = this.totalSamples;
	var start = mod0(this.n - nSamples, len);
	var data = this.data;
	var acc = 0;
	for (var i = 0; i < nSamples; i++) {
		var x = data[(start + i) % len];
		if (!isNaN(x)) {
			min = Math.min(first ? x : min, x);
			max = Math.max(first ? x : max, x);
			first = false;
		} else {
			x = 0;
		}
		ret[i] = x;
	}
	return {
		data: ret,
		max: max,
		min: min,
	};
};


/*
 * Transcribe Bitmain API results to our format
 */

var fieldsRenameChainNum = {
	'chain_rate': 'ratechip',
	'chain_rateideal': 'rateideal',
	'voltage': 'voltage',
	'freq_avg': 'frequency',
	'temp': 'temp1',
	'temp2_': 'temp2',
	'chain_acn': 'asics',
	'chain_cores': 'cores',
	'chain_hw': 'hwerrors',
	'chain_hwrate': 'hwerrorsrate',
};

var fieldsRenameChain = {
	'freq_desc': 'frequency_desc',
	'chain_acs': 'acs',
};

var sumFieldsBmminer = {
	//'ratechip': listSum,
	'rateideal': listSum,
	//'frequency': listAvg,
	'temp1': listMax,
	'temp2': listMax,
	'asics': listSum,
	'cores': listSum,
	'hwerrors': listSum,
	'hwerrorsrate': listSum,
};

function transcribeApiCommon(json, out)
{
	/* determine miner type */
	var reqStatsTop = json.stats[0].STATS;
	if (reqStatsTop && reqStatsTop[0] && reqStatsTop[0].Type == 'braiins-am1-s9') {
		out.type = 'bmminer';
	} else {
		out.type = 'cgminer';
	}

	/* parse pools */
	var outPools = [];
	var reqPools = json.pools[0].POOLS;
	for (var i in reqPools) {
		/* TODO processing */
		var reqPool = reqPools[i];
		reqPool.id = parseFloat(i) + 1;
		outPools.push(reqPool);
	}
	out.pools = outPools;

	/* parse fan control */
	var reqFanCtrl = json.fanctrl[0].FANCTRL[0];
	out.fanctrl = reqFanCtrl;
	var mode = reqFanCtrl.Mode;
	switch (reqFanCtrl.Mode) {
		case "automatic":
			mode = "Automatic Fan Control";
			reqFanCtrl.TargetPwm = undefined;
			break;
		case "manual":
			mode = "Fixed Fan Speed";
			reqFanCtrl.TargetTemp = undefined;
			break;
		case "emergency":
			mode = "Fans Full Speed";
			reqFanCtrl.TargetPwm = undefined;
			reqFanCtrl.TargetTemp = undefined;
			break;
		default:
			break;
	}
	out.fanctrl.ModeStr = mode;
}

function transcribeApiCommonFixup(json, out)
{
	var tabStats = out.stats;
	var sum = tabStats.Accepted + tabStats.Rejected;
	if (sum > 0) {
		tabStats.RejectedPerc = tabStats.Rejected / sum * 100;
	}
}

function transcribeApiBmminer(json, out)
{
	/* parse chains */
	var reqSummary = json.summary[0].SUMMARY[0];
	var reqStats = json.stats[0].STATS[1];
	var outChains = [];
	for (var i = 1; i <= 16; i++) {
		var r = reqStats['chain_rate' + i];
		if (typeof(r) == "string" && r != '') {
			var outChain = {
				ID: i,
			};
			/* parse numerical elements */
			for (key in fieldsRenameChainNum) {
				var as = fieldsRenameChainNum[key];
				var val = reqStats[key + i];
				outChain[as] = parseFloat(val);
			}

			/* parse non-numerical elements */
			for (key in fieldsRenameChain) {
				var as = fieldsRenameChain[key];
				var val = reqStats[key + i];
				if (typeof(val) == "string")
					outChain[as] = val;
			}
			outChains.push(outChain);
		}
	}

	/* parse fans */
	var outFans = [];
	for (var i = 1; i <= 8; i++) {
		var f = reqStats['fan' + i];
		if (f && parseFloat(f) > 0) {
			var outFan = { id: i, rpm: parseFloat(f) };
			outFans.push(outFan);
		}
	}
	out.fans = outFans;

	/* parse stats */
	var outSum = {
		'ratereal': parseFloat(reqSummary['GHS av']),
		'ratechip': parseFloat(reqStats['total_rate']),
		'rateideal': parseFloat(reqStats['total_rateideal']),
		'frequency': parseFloat(reqStats['total_freqavg']),
	};
	for (key in sumFieldsBmminer) {
		outSum[key] = sumFieldsBmminer[key](pickKey(outChains, key));
	};
	outChains.push(outSum);
	out.stats = reqSummary;
	out.chains = outChains;
}

var sumFieldsCgminer = {
	'MHS 5s': listSum,
	'maximal MHS': listSum,
	'TempAVG': listAvg,
	'TempMIN': listMin,
	'TempMAX': listMax,
	'CHIP': listSum,
	'CORE': listSum,
	'Hardware Errors': listSum,
	'Hardware Error Rate': listSum,
};


function transcribeApiCgminer(json, out)
{
	var reqSummary = json.summary[0].SUMMARY[0];
	var reqDevs = json.devs[0].DEVS;
	var outSum = {};
	for (key in sumFieldsCgminer) {
		outSum[key] = sumFieldsCgminer[key](pickKey(reqDevs, key));
	};
	reqDevs.push(outSum);

	out.stats = reqSummary;
	out.chains = reqDevs;
}


function transcribeApi(json)
{
	var reqStatsTop = json.stats[0].STATS;
	var out = {};
	transcribeApiCommon(json, out);
	if (out.type == 'bmminer') {
		transcribeApiBmminer(json, out);
	} else {
		transcribeApiCgminer(json, out);
	}
	transcribeApiCommonFixup(json, out);
	return out;
}

/*
 * Build HTML tables
 */

function makeDataCell(kind, id, value, onclick, description)
{
	var node;

	/* create text with description */
	if (description != undefined) {
		node = document.createElement('abbr');
		node.title = description;
	} else {
		node = document.createElement('span');
	}
	/* does it have an id? */
	if (id) {
		node.id = id;
	}
	node.innerHTML = value;

	/* make it clickable? */
	if (onclick) {
		var a = document.createElement('a');
		a.href = "#";
		a.onclick = onclick;
		a.appendChild(node);
		node = a;
	}

	/* wrap it into cell */
	var col = document.createElement(kind);
	col.appendChild(node);

	return col;
}

function makeRow(cells)
{
	var row = document.createElement('tr');
	for (var i in cells) {
		row.appendChild(cells[i]);
	}
	return row;
}

function clearChildren(name)
{
	var e = document.getElementById(name);
	while (e.hasChildNodes()) {
		e.removeChild(e.lastChild);
	}
}

function setAbbr(name, value)
{
	var e = document.getElementById(name);
	e.title = value;
}

function setId(name, value)
{
	var e = document.getElementById(name);
	e.innerHTML = value === undefined ? '-' : value;
}

function setHighlighted(name, on)
{
	var e = document.getElementById(name);
	while (e.tagName != 'TD') {
		e = e.parentElement;
	}
	e.className = on ? 'highlighted' : '';
}

function setStatus(text)
{
	setId('status', text);
}

function initGraph(state)
{
	//console.log('state', state.svgDoc, state.svg);
	for (var k = 0; k < MAX_GRAPHS; ++k) {
		state.line[k] = state.svgDoc.getElementById('hashrate' + (k + 1));
	}
	state.label_25 = state.svgDoc.getElementById('label_25');
	state.label_50 = state.svgDoc.getElementById('label_50');
	state.label_75 = state.svgDoc.getElementById('label_75');
	state.graph_name = state.svgDoc.getElementById('graph_name');

	var WIDTH = state.svg.offsetWidth - 2;
	for (min = 1; min * 60 < DRAW_HISTORY_SEC; min++) {
		var x = (1 - min * 60 / DRAW_HISTORY_SEC) * WIDTH;
		var line = state.svgDoc.createElementNS('http://www.w3.org/2000/svg', 'line');
		line.setAttribute('x1', x);
		line.setAttribute('y1', 0);
		line.setAttribute('x2', x);
		line.setAttribute('y2', '100%');
		line.setAttribute('style', 'stroke:black;stroke-width:0.1');

		var text = state.svgDoc.createElementNS('http://www.w3.org/2000/svg', 'text');
		text.setAttribute('x', x + 5);
		text.setAttribute('y', 15);
		text.setAttribute('style', 'fill:#999999; font-size:9pt');
		text.appendChild(state.svgDoc.createTextNode(min + 'm'));

		state.label_25.parentNode.appendChild(line);
		state.label_25.parentNode.appendChild(text);
	}
}

function drawGraphs(state, bundles)
{
	var WIDTH = state.svg.offsetWidth - 2;
	var HEIGHT = state.svg.offsetHeight - 2;

	//var min = NaN;
	var min = 0;
	var max = NaN;

	for (var k = 0; k < MAX_GRAPHS; k++) {
		var bundle = bundles[k];
		if (bundle) {
			min = minNaN(min, bundle.min);
			max = maxNaN(max, bundle.max);
		}
	}
	min = defaultNaN(min, 0) * 0.9;
	max = defaultNaN(max, min + 1) * 1.1;

	for (var k = 0; k < MAX_GRAPHS; k++) {
		var bundle = bundles[k];
		if (!bundle) {
			state.line[k].style.visibility = 'hidden';
			continue;
		}
		var data = bundle.data;
		var len = data.length;
		var h = Math.max(max - min, 1);
		var points = '0,' + HEIGHT;
		for (var i = 0; i < len; i++) {
			var y = HEIGHT - Math.floor(HEIGHT * (data[i] - min) / h);
			var x = i * WIDTH / (len - 1);
			points += ' ' + x + ',' + y;
		}
		points += ' ' + WIDTH + ',' + HEIGHT;
		state.line[k].setAttribute('points', points);
		state.line[k].style.visibility = 'visible';
	}

	state.label_25.firstChild.data = (0.25 * (max - min)).toFixed(2);
	state.label_50.firstChild.data = (0.50 * (max - min)).toFixed(2);
	state.label_75.firstChild.data = (0.75 * (max - min)).toFixed(2);
	state.graph_name.firstChild.data = state.currentGraphsAnnot;
}

/*
 * Field description
 */

function formatfix(n) { return function (x) { return x ? x.toFixed(n) : x; }; }
function formatfixsuf(n,suf) { return function (x) { return x ? x.toFixed(n) + suf : x; }; }
function formattemp(n) { return formatfixsuf(n, ' &deg;C'); }
function formatyesno(v) { return v ? "yes" : "no"; }
function formatsec(sec) {
	if (!sec) return sec;
	var day = 24 * 3600;
	var days = (sec / day) | 0;
	sec -= days * day;
	var hours = (sec / 3600) | 0;
	sec -= hours * 3600;
	var min = (sec / 60) | 0;
	sec -= min * 60;

	var t = '';
	if (days > 0) t += days + ' days ';
	t += hours + ':' + zeroPad(min, 2) + ':' + zeroPad(sec, 2);

	return t;
}

var fieldsSummary = [
	{
		key: 'Hashrate1m',
		name: 'Gh/s 1m',
		graph: true,
		desc: 'Average hashrate (1 minute window, Gh/s)',
		format: formatfix(2),
	},
	{
		key: 'Hashrate15m',
		name: 'Gh/s 15m',
		graph: true,
		desc: 'Average hashrate (15 minute window, Gh/s)',
		format: formatfix(2),
	},
	{
		key: 'Hashrate24h',
		name: 'Gh/s 24h',
		graph: true,
		desc: 'Average hashrate (24 hour window, Gh/s)',
		format: formatfix(2),
	},
	{
		key: 'Found Blocks',
		name: 'Found',
		desc: 'Found Blocks',
		graph: true,
	},
	{
		key: 'Accepted',
		name: 'Acc',
		desc: 'Accepted shares',
		graph: true,
	},
	{
		key: 'Difficulty Accepted',
		name: 'Diff#A',
		desc: 'Difficulty Accepted',
		graph: true,
	},
	{
		key: 'Rejected',
		name: 'Rej',
		desc: 'Rejected shares',
		graph: true,
	},
	{
		key: 'Difficulty Rejected',
		name: 'Diff#R',
		desc: 'Difficulty Rejected',
		graph: true,
	},
	{
		key: 'RejectedPerc',
		name: 'Rej. %',
		graph: true,
		desc: 'Ratio of rejected shares to all submitted shares (in percent)',
		format: formatfixsuf(3, '%'),
	},
	{
		key: 'Elapsed',
		name: 'Elapsed',
		format: formatsec,
	},
	{
		key: 'Hardware Errors',
		name: 'HW err',
		desc: 'Hardware Errors',
		graph: true,
	},
	{
		key: 'Work Utility',
		name: 'WU',
		desc: 'Work Utility',
		graph: true,
		format: formatfix(0),
	},
];
var fieldsPool = [
	{
		key: 'id',
		name: 'Pool ID',
	},
	{
		key: 'URL',
	},
	{
		key: 'User',
	},
	{
		key: 'Status',
	},
	{
		key: 'Accepted',
		name: 'Acc',
		desc: 'Accepted shares',
		graph: true,
	},
	{
		key: 'Rejected',
		name: 'Rej',
		desc: 'Rejected shares',
		graph: true,
	},
/*
	{
		key: 'Discarded',
		graph: true,
	},
*/
	{
		key: 'Stale',
		graph: true,
	},
	{
		key: 'LastDiff',
		graph: true,
		format: formatfix(0),
	},
	{
		key: 'Asic Boost',
		format: formatyesno,
	},
];
var fieldsChainCgminer = [
	{
		key: 'ID',
		name: 'Chain ID',
	},
	{
		key: 'MHS 5s',
		name: 'Real Rate',
		desc: 'Hashrate computed from submitted shares (Gh/s, 5s average)',
		graph: true,
		format: function (x) { return (x/1000).toFixed(2); },
	},
	{
		key: 'maximal MHS',
		name: 'Maximal Rate',
		desc: 'Theoretical hashrate with current number of cores (Gh/s)',
		format: function (x) { return (x/1000).toFixed(2); },
	},
/*
	{
		key: 'voltage',
		name: 'Voltage',
	},
	{
		key: 'frequency',
		name: 'Frequency',
	},
*/
	{
		key: 'TempAVG',
		name: 'Temp avg.',
		graph: true,
		desc: 'Average temperature over all chips (degree C)',
		format: formattemp(1),
	},
	{
		key: 'TempMIN',
		name: 'Temp min.',
		desc: 'Minimal temperature over all chips (degree C)',
		graph: true,
		format: formattemp(1),
	},
	{
		key: 'TempMAX',
		name: 'Temp max.',
		graph: true,
		desc: 'Maximal temperature over all chips (degree C)',
		format: formattemp(1),
	},
	{
		key: 'CHIP',
		name: 'ASIC#',
		desc: 'Number of ASIC chips on chain',
	},
	{
		key: 'CORE',
		name: 'CORE#',
		desc: 'Number of cores on chain',
	},
	{
		key: 'Hardware Errors',
		name: 'HWerr',
		desc: 'Absolute number of hardware errors since miner started',
		graph: true,
	},
	{
		key: 'Hardware Error Rate',
		name: 'HWerr/h',
		desc: 'Average number of hardware errors per hour',
		graph: true,
		format: formatfix(1),
	},
];
var fieldsChainBmminer = [
	{
		key: 'ID',
		name: 'Chain ID',
	},
	{
		key: 'ratereal',
		name: 'Real Rate',
		desc: 'Hashrate computed from submitted shares (Gh/s)',
		graph: true,
		format: formatfix(2),
	},
	{
		key: 'ratechip',
		name: 'Chip Rate',
		desc: 'Hashrate reported by chips (Gh/s)',
		graph: true,
		format: formatfix(2),
	},
	{
		key: 'rateideal',
		name: 'Ideal Rate',
		desc: 'Theoretical hashrate at current frequency (Gh/s)',
		format: formatfix(2),
	},
	{
		key: 'voltage',
		name: 'Voltage',
		desc: 'Chain voltage (Volts)',
	},
	{
		key: 'frequency',
		name: 'Frequency',
		desc: 'Average chip frequency on chain (MHz)',
		abbr: 'frequency_desc',
		format: function (x, data) {
			var desc = data.frequency_desc;
			if (desc == null) return x;
			var out = x.toFixed(0);
			var color = null;
			var m = /overclocked by factor ([0-9\.]+\.[0-9]+)/.exec(desc);
			if (m != null) {
				var f = parseFloat(m[1]);
				color = 'green';
				if (f > 1)
					color = '#909';
			}
			if (desc.search(/user/) >= 0) {
				color = 'red';
			}
			if (color != null)
				out = '<font color=' + color + '>' + out + '</font>'
			return out;
		},

	},
	{
		key: 'temp1',
		name: 'Temp 1',
		graph: true,
		desc: 'Sensor 1 temperature (degree C)',
		format: formattemp(0),
	},
	{
		key: 'temp2',
		name: 'Temp 2',
		graph: true,
		desc: 'Sensor 2 temperature (degree C)',
		format: formattemp(0),
	},
	{
		key: 'asics',
		name: 'ASIC#',
		abbr: 'acs',
		desc: 'Number of ASIC chips on chain',
	},
	{
		key: 'cores',
		name: 'CORE#',
		desc: 'Number of cores on chain',
	},
	{
		key: 'hwerrors',
		name: 'HWerr',
		desc: 'Absolute number of hardware errors since miner started',
		graph: true,
	},
	{
		key: 'hwerrorsrate',
		name: 'HWerr/h',
		desc: 'Average number of hardware errors per hour',
		graph: true,
		format: function (x) { return x.toFixed(1); },
	},
];
var fieldsFan = [
	{
		key: 'id',
		name: 'Fan ID',
	},
	{
		key: 'rpm',
		name: 'RPM',
		desc: 'Revolutions Per Minute',
		graph: true,
	},
];

var fieldsFanCtrl = [
	{
		key: 'ModeStr',
		name: 'Mode',
		desc: 'Algorithm that controls fan speed',
		graph: true,
	},
	{
		key: 'TargetTemp',
		name: 'Target Temp',
		format: formattemp(0),
	},
	{
		key: 'TargetPwm',
		name: 'Target Speed',
		format: formatfixsuf(0, '%'),
	},
	{
		key: 'Interval',
		name: 'Interval',
		format: formatfixsuf(1, ' sec'),
		desc: 'How often is temperature measure in seconds',
	},
	{
		key: 'Temperature',
		format: formattemp(1),
		name: 'Temp',
		desc: 'Current temperature that is used as input to fan control',
		graph: true,
	},
	{
		key: 'Output',
		name: 'Fan Speed',
		format: formatfixsuf(0, '%'),
		desc: 'Current fan speed',
		graph: true,
	},
];



/* Each dictionary defines one "table". The keys mean the following:

   elementId:	ID of HTML table element
   keys:	list of keys to show (in the JSON request)
   datasetKeys:	list of keys to graph (constant values like voltage does not
		make sense to graph
   prefix:	HTML ID prefix string (% gets replaced by index of table
		entry)
   nrowsGet	function that returns number of rows in table
   rowsGet	function that returns row by index
   getRowCols	Name of fields that are shown when first column is clicked.
		Absence of this function means: first column has default
		functionality.
   getColSubrows Indexes of rows that are shown when the column heading is
		clicked. Absence of this function means: heading not
		clickable.
*/

var tables = [
	{
		elementId: 'chains-table',
		getFields: function (data) {
			if (data.type == 'bmminer')
				return fieldsChainBmminer;
			else
				return fieldsChainCgminer;
		},
		prefix: 'chain%',
		nrowsGet: function (data) { return data.chains.length; },
		rowGet: function (data, i) { return data.chains[i]; },
		getColSubrows: function (data, key) {
			if (key == 'ratereal')
				return [];
			return range(0, data.chains.length - 1);
		},
		getRowName: function (data, i) {
			if (i == data.chains.length - 1)
				return 'aggregated';
			else
				return 'chain ' + data.chains[i].ID;
		},
	},
	{
		elementId: 'pools-table',
		getFields: function (data) { return fieldsPool; },
		prefix: 'pool%',
		nrowsGet: function (data) { return data.pools.length; },
		rowGet: function (data, i) { return data.pools[i]; },
		getColSubrows: function (data, k) { return range(0, data.pools.length); },
		getRowName: function (data, i) { return 'pool ' + data.pools[i].id; },
	},
	{
		elementId: 'summary-table',
		getFields: function (data) { return fieldsSummary; },
		prefix: 'stat',
		nrowsGet: function (data) { return 1; },
		rowGet: function (data, i) { return data.stats; },
	},
	{
		elementId: 'fanctrl-table',
		getRowColumns: function (data) { return ['Temperature', 'Output']; },
		getFields: function (data) { return fieldsFanCtrl; },
		prefix: 'fanctrl',
		nrowsGet: function (data) { return 1; },
		rowGet: function (data, i) { return data.fanctrl; },
	},
	{
		elementId: 'fans-table',
		getFields: function (data) { return fieldsFan; },
		prefix: 'fan%',
		nrowsGet: function (data) { return data.fans.length; },
		rowGet: function (data, i) { return data.fans[i]; },
		getColSubrows: function (data, k) { return range(0, data.fans.length); },
		getRowName: function (data, i) { return 'fan ' + data.fans[i].id; },
		onlyFor: 'bmminer',
	},

];

function getName(field)
{
	return field.name || field.key;
}

function makeId(prefix, key, id)
{
	return prefix.replace('%', id) + '_' + key.replace(' ', '_');
}

function changeOnclickGen(state, graphIds, annot)
{
	if (graphIds.length == 0)
		return null;
	return function () {
		switchToGraphs(state, graphIds, annot);
		return false;
	}
}

/* Generate click function for cols*rows cartesian product */
function getClickFn(state, def, data, col_fields, row_ids)
{
	/* figure out graph description */
	/* format is: colname1, colname2, ... (rowname1, rowname2, ...) */
	var annot = col_fields.map(
		function (field) { return getName(field); }
	).join(', ');
	/* name of rows is optional */
	if (def.getRowName) {
		rowNames = row_ids.map(
			function (i) {
				return def.getRowName(data, i);
			}
		);
		annot += ' (' + rowNames.join(', ') + ')';
	}

	/* figure out field ids */
	var ids = [];
	col_fields.forEach(
		function (field) {
			row_ids.forEach(
				function (i) {
					ids.push(makeId(def.prefix, field.key, i));
				}
			);
		}
	);

	/* generate function */
	return changeOnclickGen(state, ids, annot);
}

/* Generate click function for column */
function getColClickFn(state, def, data, col_field)
{
	console.assert(def.getColSubrows && col_field.graph);
	return getClickFn(state, def, data, [col_field], def.getColSubrows(data, col_field.key));
}

/* Generate click function for row */
function getRowClickFn(state, def, data, row_id)
{
	console.assert(def.getRowColumns);
	var col_fields = def.getRowColumns(data).map(
		function (keyName) { return lookupByKey(def.getFields(data), 'key', keyName); }
	);
	return getClickFn(state, def, data, col_fields, [row_id]);
}

function getDefaultGraphFn(state, data)
{
	var def = lookupByKey(tables, 'elementId', 'summary-table');
	var field = lookupByKey(def.getFields(data), 'key', 'Hashrate1m');
	return getClickFn(state, def, data, [field], [0]);
}

function buildTable(state, def, data)
{
	var table = document.getElementById(def.elementId);
	var th = def.getFields(data).map(function (field) {
		var name = getName(field);
		var fn = null;
		if (field.graph && def.getColSubrows) {
			fn = getColClickFn(state, def, data, field);
		}
		return makeDataCell('th', null, name, fn, field.desc);
	});
	var rows = [th];
	for (var row_i = 0; row_i < def.nrowsGet(data); row_i++) {
		var fields = def.getFields(data);
		var row = [];
		for (col_i in fields) {
			var field = fields[col_i];
			var id = makeId(def.prefix, field.key, row_i);
			var clickFn = null;
			if (field.graph) {
				if (col_i == 0 && def.getRowColumns) {
					clickFn = getRowClickFn(state, def, data, row_i);
				} else {
					clickFn = getClickFn(state, def, data, [field], [row_i]);
				}
				state.datasets[id] = new Dataset(SAMPLING_FREQ, KEEP_HISTORY_SEC);
			}
			var is_subrow = def.getColSubrows && def.getColSubrows(data, field.key).indexOf(row_i) >= 0;
			var desc = field.abbr && is_subrow ? "" : undefined;
			var td = makeDataCell('td', id, '-', clickFn, desc);
			row.push(td);
		}
		rows.push(row);
	}
	rows.forEach(
		function (row) { return table.appendChild(makeRow(row)); }
	);
}

function updateTable(state, def, data)
{
	var table = document.getElementById(def.elementId);
	/* check if number of rows from server (API) matches dimension of the table */
	/* the extra +1 is for <th> element */
	if (table.childElementCount != 1 + def.nrowsGet(data)) {
		clearChildren(def.elementId);
		buildTable(state, def, data);
	}

	for (var i = 0; i < def.nrowsGet(data); i++) {
		var row = def.rowGet(data, i);
		def.getFields(data).forEach(function (field) {
			var id = makeId(def.prefix, field.key, i);
			var val = row[field.key];
			var show = val;
			if (val && field.format)
				show = field.format(show, row);
			setId(id, show);
			if (field.abbr) {
				setAbbr(id, row[field.abbr]);
			}
			if (field.graph) {
				state.datasets[id].push(val);
			}
		});
	}
}

function isTableOk(data, def)
{
	return !def.onlyFor || def.onlyFor == data.type;
}

function updateTables(state, data)
{
	tables.forEach(
		function (x) {
			if (isTableOk(data, x))
				updateTable(state, x, data);
		}
	);
	if (state.currentGraphs.length == 0) {
		/* clicks on link to default graph fn */
		getDefaultGraphFn(state, data)();
	}
}

function updateTablesNoData(state, isDead)
{
	for (id in state.datasets) {
		if (isDead)
			state.datasets[id].push(0);
		else
			state.datasets[id].pushLast();
	}
}

function doRequest(state)
{
	var xhr = new XMLHttpRequest();
	var url = '/cgi-bin/luci/admin/status/miner/api_status';
	xhr.open('GET', url, true);

	xhr.timeout = PAGE_TICK_DURATION_MS * 0.9;
	xhr.onreadystatechange = function() {
		if (xhr.readyState == 4) {
			state.firstRequest = false;
			try {
				state.json = eval('(' + xhr.responseText + ')');
			} catch(e) {
				state.json = null;
			};
		}
	};
	xhr.ontimeout = function() {
		console.log("timeout");
	};
	xhr.send(null);
}

function redrawGraphs(state)
{
	var bundles = [];
	state.currentGraphs.map(
		function (id) {
			var dataset = state.datasets[id];
			if (dataset)
				bundles.push(dataset.getBundle(DRAW_HISTORY_SEC));
		});
	drawGraphs(state, bundles);
}

function switchToGraphs(state, graphNames, annot)
{
	console.log('change to', annot, graphNames);
	state.currentGraphs.forEach(
		function (id) { setHighlighted(id, false); }
	);
	state.currentGraphs = graphNames;
	state.currentGraphsAnnot = annot;
	setId('what', ': '+ annot);
	state.currentGraphs.forEach(
		function (id) { setHighlighted(id, true); }
	);

	redrawGraphs(state);
}

function runPageTick(state)
{
	/* process current request */
	if (state.json) {
		if (state.json.code) {
			var code = state.json.code;
			if (code == 'error') {
				setStatus('Error when connecting to CGMiner');
			} else if (code == 'stopped') {
				setStatus('CGMiner is stopped!');
			} else if (code == 'started') {
				var pid = state.json.pid;
				if (state.lastPID != null && state.lastPID != pid) {
					setStatus('CGMiner is trying to start but keeps restarting, maybe wrong configuration?');
				} else {
					setStatus('CGMiner is starting, waiting for hardware...');
					state.lastPID = pid;
				}
			}
			updateTablesNoData(state, true);
		} else {
			var data = transcribeApi(state.json);
			updateTables(state, data);
			state.deadForMs = 0;
			setStatus('OK');
			state.lastPID = null;
		}
	} else {
		state.deadForMs += PAGE_TICK_DURATION_MS;
		var dead = state.deadForMs >= PAGE_DEAD_TIMEOUT_MS;

		updateTablesNoData(state, dead);
		if (!state.firstRequest) {
			setStatus(dead ? "Can't connect to miner" : 'Stalled');
		}
	}

	/* clear state */
	state.json = null;

	/* make new request */
	doRequest(state);
	redrawGraphs(state);
}

function initPage(svg, svgDoc)
{
	var globalState = {
		json: null,
		lastPID: null,
		line: [],
		datasets: {},
		deadForMs: PAGE_DEAD_TIMEOUT_MS,
		svg: svg,
		svgDoc: svgDoc,
		currentGraphs: [],
		currentGraphsAnnot: '',
		firstRequest: true,
	};

	initGraph(globalState);

	var sched = new Scheduler(
		function () { return runPageTick(globalState); },
		PAGE_TICK_DURATION_MS
	);
	sched.run();
}

function waitForSvg(id, callback)
{
	var svg = document.getElementById(id);
	var svgDoc;
        try {
            svgDoc = svg.getSVGDocument
                ? svg.getSVGDocument() : svg.contentDocument;
        } catch(e) {
            svgDoc = document.embeds[id].firstElementChild;
        }
	if (!svgDoc) {
		console.log('svg not there, waiting...');
		setTimeout(waitForSvg, 500, id, callback);
	} else {
		callback(svg, svgDoc);
	}
}

waitForSvg('hashrate-svg', initPage);

//]]></script>

<div style="text-align:right"><small id="scale"></small></div>
<br />

<%+footer%>
