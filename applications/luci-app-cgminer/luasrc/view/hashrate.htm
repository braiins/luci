<%#
 Copyright 2010 Jo-Philipp Wich <jow@openwrt.org>
 Licensed to the public under the Apache License 2.0.
-%>

<%+header%>

<script type="text/javascript" src="<%=resource%>/cbi.js?v=git-18.296.46953-d87b0c8"></script>

	<style>
table.stats td { border: 1px solid black !important; padding: 4px; min-width: 5em; text-align: center; }
table.stats th { text-align: center; font-weight: bold; }
a { text-decoration: none; }
table.stats { width: auto; margin-top: 1em; } //margin-left: auto; margin-right: auto; }
	</style>

<h1>Miner Status<span id="what"</span></h1>
<p>API connection status: <span id="status">Not connected</span></p>

<embed id="hashrate-svg" style="width:100%; height:300px; border:1px solid #000000; background-color:#FFFFFF" src="/luci-static/resources/miner_graph.svg">

<table class="stats" id="chains-table" />
<table class="stats" id="pools-table" />
<table class="stats" id="summary-table" />
<table class="stats" id="fans-table" />
<table />

<script type="text/javascript">//<![CDATA[

/*
 * "Constants"
 */

/* must match SVG */
var MAX_GRAPHS = 3;
var PAGE_TICK_DURATION_MS = 1000;
var PAGE_DEAD_TIMEOUT_MS = 5000;
var API_PORT = 4028;
/* draw last ... seconds of history */
var DRAW_HISTORY_SEC = 5 * 60;
var SAMPLING_FREQ = 1 / (PAGE_TICK_DURATION_MS / 1000);
var KEEP_HISTORY_SEC = DRAW_HISTORY_SEC * 1.2;


/*
 * Utility functions
 */

function mod0(x, y) {
	return (x % y + y) % y;
}
function defaultNaN(x, def) {
	return isNaN(x) ? def : x;
}
function minNaN(x, y) {
	if (isNaN(x))
		return y;
	if (isNaN(y))
		return x;
	return Math.min(x, y);
}
function maxNaN(x, y) {
	if (isNaN(x))
		return y;
	if (isNaN(y))
		return x;
	return Math.max(x, y);
}

function listMax(list) {
	var max = list[0];
	for (i in list) {
		max = Math.max(max, list[i]);
	}
	return max;
}
function listMin(list) {
	var min = list[0];
	for (i in list) {
		min = Math.min(min, list[i]);
	}
	return min;
}
function listSum(list) {
	var sum = 0;
	for (i in list) {
		sum += list[i];
	}
	return sum;
}
function listAvg(list) {
	var len = list.length;
	if (len == 0)
		return 0;
	return listSum(list) / len;
}
function pickKey(list, key)
{
	var out = [];
	for (x in list)
		out.push(list[x][key]);
	return out;
}
function range(a, b)
{
	var t = [];
	for (var i = a; i < b; i++)
		t.push(i);
	return t;
}

/*
 * Scheduler class (via closures)
 */

function Scheduler(callback, timeout)
{
	var run;
	run = function () {
		setTimeout(run, timeout);
		callback();
	};
	return {
		run: run
	};
}

/*
 * Dataset class (via prototypes)
 */

function Dataset(samplingFreq, secondsOfHistory)
{
	this.samplingFreq = samplingFreq;
	/* At 2Hz sampling rate and 4 seconds you needs 2*4 = 8 samples */
	this.totalSamples = secondsOfHistory * samplingFreq;
	/* Data is "ring buffer" */
	this.data = [];
	/* "n" is pointer to ring buffer */
	this.n = 0;
	/* last sample to fill-in for missing samples */
	this.last = 0;
	this.resetCounter();
}

Dataset.prototype.resetCounter = function ()
{
	/* computed min/max/avg since last reset */
	this.countMax = NaN;
	this.countMin = NaN;
	this.countAvgSum = 0;
	this.countAvgN = 0;
};

Dataset.prototype.push = function (sample)
{
	this.data[this.n] = sample;
	this.n += 1;
	if (this.n >= this.totalSamples)
		this.n = 0;
	this.last = sample;
	/* compute avg */
	this.countAvgSum += sample;
	this.countAvgN++;
	this.countMin = minNaN(this.countMin, sample);
	this.countMax = maxNaN(this.countMax, sample);
};

Dataset.prototype.pushLast = function ()
{
	this.push(this.last);
};

Dataset.prototype.getStatsStr = function ()
{
	if (this.countAvgN == 0)
		return "not yet";
	var avg = this.countAvgSum / this.countAvgN;
	return 'Avg: ' + avg.toFixed(2) +
		' Min: ' + this.countMin.toFixed(2) +
		' Max: ' + this.countMax.toFixed(2)
}

Dataset.prototype.getBundle = function (nSeconds)
{
	var nSamples = this.samplingFreq * nSeconds;
	var ret = [];
	var first = true;
	/*
         * min and max gets overwritten in first iteration with some real
         * value. the only case "NaN" is returned is when the returned
         * dataSet is empty.
         */
	var max = NaN, min = NaN;
	var len = this.totalSamples;
	var start = mod0(this.n - nSamples, len);
	var data = this.data;
	var acc = 0;
	for (var i = 0; i < nSamples; i++) {
		var x = data[(start + i) % len];
		if (!isNaN(x)) {
			min = Math.min(first ? x : min, x);
			max = Math.max(first ? x : max, x);
			first = false;
		} else {
			x = 0;
		}
		ret[i] = x;
	}
	return {
		data: ret,
		max: max,
		min: min,
	};
};


/*
 * Transcribe Bitmain API results to our format
 */

var fieldsRenameChain = {
	'chain_rate': 'ratechip',
	'chain_rateideal': 'rateideal',
	'voltage': 'voltage',
	'freq_avg': 'frequency',
	'temp': 'temp1',
	'temp2_': 'temp2',
	'chain_acn': 'cores',
	'chain_hw': 'hwerrors',
	'chain_hwrate': 'hwerrorsrate',
};
var sumFieldsBmminer = {
	//'ratechip': listSum,
	'rateideal': listSum,
	//'frequency': listAvg,
	'temp1': listMax,
	'temp2': listMax,
	'cores': listSum,
	'hwerrors': listSum,
	'hwerrorsrate': listSum,
};

function transcribeApiBmminer(json)
{
	var outChains = [];
	var outPools = [];

	var reqSummary = json.summary[0].SUMMARY[0];

	var reqPools = json.pools[0].POOLS;
	for (var i in reqPools) {
		/* TODO processing */
		var reqPool = reqPools[i];
		reqPool.id = parseFloat(i) + 1;
		outPools.push(reqPool);
	}

	var reqStats = json.stats[0].STATS[1];
	for (var i = 1; i <= 16; i++) {
		var r = reqStats['chain_rate' + i];
		if (typeof(r) == "string" && r != '') {
			var outChain = {
				ID: i,
			};
			for (key in fieldsRenameChain) {
				var as = fieldsRenameChain[key];
				var val = reqStats[key + i];
				outChain[as] = parseFloat(val);
			}
			outChains.push(outChain);
		}
	}
	var outFans = [];
	for (var i = 1; i <= 8; i++) {
		var f = reqStats['fan' + i];
		if (f && parseFloat(f) > 0) {
			var outFan = { id: i, rpm: parseFloat(f) };
			outFans.push(outFan);
		}
	}
	var outSum = {
		'ratereal': parseFloat(reqSummary['GHS av']),
		'ratechip': parseFloat(reqStats['total_rate']),
		'rateideal': parseFloat(reqStats['total_rateideal']),
		'frequency': parseFloat(reqStats['total_freqavg']),
	};
	for (key in sumFieldsBmminer) {
		outSum[key] = sumFieldsBmminer[key](pickKey(outChains, key));
	};
	outChains.push(outSum);
	var out = {
		type: 'bmminer',
		stats: reqSummary,
		pools: reqPools,
		chains: outChains,
		fans: outFans,
	};
	return out;
}

var sumFieldsCgminer = {
	'MHS 5s': listSum,
	'maximal MHS': listSum,
	'TempAVG': listAvg,
	'TempMIN': listMin,
	'TempMAX': listMax,
	'CHIP': listSum,
	'CORE': listSum,
	'Hardware Errors': listSum,
	'Hardware Error Rate': listSum,
};


function transcribeApiCgminer(json)
{
	var outPools = [];

	var reqSummary = json.summary[0].SUMMARY[0];

	var reqPools = json.pools[0].POOLS;
	for (var i in reqPools) {
		/* TODO processing */
		var reqPool = reqPools[i];
		reqPool.id = parseFloat(i) + 1;
		outPools.push(reqPool);
	}

	var reqDevs = json.devs[0].DEVS;

	var outSum = {};
	for (key in sumFieldsCgminer) {
		outSum[key] = sumFieldsCgminer[key](pickKey(reqDevs, key));
	};
	reqDevs.push(outSum);

	var out = {
		type: 'cgminer',
		stats: reqSummary,
		pools: reqPools,
		chains: reqDevs,
	};
	return out;
}


function transcribeApi(json)
{
	var reqStatsTop = json.stats[0].STATS;
	if (reqStatsTop && reqStatsTop[0] && reqStatsTop[0].Type == 'braiins-am1-s9') {
		return transcribeApiBmminer(json);
	} else {
		return transcribeApiCgminer(json);
	}
}

/*
 * Build HTML tables
 */

function makeDataCell(kind, id, value, onclick, description)
{
	var node;

	/* create text with description */
	if (description) {
		node = document.createElement('abbr');
		node.title = description;
	} else {
		node = document.createElement('span');
	}
	/* does it have an id? */
	if (id) {
		node.id = id;
	}
	node.innerHTML = value;

	/* make it clickable? */
	if (onclick) {
		var a = document.createElement('a');
		a.href = "#";
		a.onclick = onclick;
		a.appendChild(node);
		node = a;
	}

	/* wrap it into cell */
	var col = document.createElement(kind);
	col.appendChild(node);

	return col;
}

function makeRow(cells)
{
	var row = document.createElement('tr');
	for (var i in cells) {
		row.appendChild(cells[i]);
	}
	return row;
}

function setId(name, value)
{
	//var id = name.replace(/\s/g, '_');
	var e = document.getElementById(name);
	e.innerHTML = value === undefined ? '-' : value;
}

function initGraph(state)
{
	//console.log('state', state.svgDoc, state.svg);
	for (var k = 0; k < MAX_GRAPHS; ++k) {
		state.line[k] = state.svgDoc.getElementById('hashrate' + (k + 1));
	}
	state.label_25 = state.svgDoc.getElementById('label_25');
	state.label_50 = state.svgDoc.getElementById('label_50');
	state.label_75 = state.svgDoc.getElementById('label_75');
	state.graph_name = state.svgDoc.getElementById('graph_name');

	var WIDTH = state.svg.offsetWidth - 2;
	for (min = 1; min * 60 < DRAW_HISTORY_SEC; min++) {
		var x = (1 - min * 60 / DRAW_HISTORY_SEC) * WIDTH;
		var line = state.svgDoc.createElementNS('http://www.w3.org/2000/svg', 'line');
		line.setAttribute('x1', x);
		line.setAttribute('y1', 0);
		line.setAttribute('x2', x);
		line.setAttribute('y2', '100%');
		line.setAttribute('style', 'stroke:black;stroke-width:0.1');

		var text = state.svgDoc.createElementNS('http://www.w3.org/2000/svg', 'text');
		text.setAttribute('x', x + 5);
		text.setAttribute('y', 15);
		text.setAttribute('style', 'fill:#999999; font-size:9pt');
		text.appendChild(state.svgDoc.createTextNode(min + 'm'));

		state.label_25.parentNode.appendChild(line);
		state.label_25.parentNode.appendChild(text);
	}
}

function drawGraphs(state, bundles)
{
	var WIDTH = state.svg.offsetWidth - 2;
	var HEIGHT = state.svg.offsetHeight - 2;

	//var min = NaN;
	var min = 0;
	var max = NaN;

	for (var k = 0; k < MAX_GRAPHS; k++) {
		var bundle = bundles[k];
		if (bundle) {
			min = minNaN(min, bundle.min);
			max = maxNaN(max, bundle.max);
		}
	}
	min = defaultNaN(min, 0) * 0.9;
	max = defaultNaN(max, min + 1) * 1.1;

	for (var k = 0; k < MAX_GRAPHS; k++) {
		var bundle = bundles[k];
		if (!bundle) {
			state.line[k].style.visibility = 'hidden';
			continue;
		}
		var data = bundle.data;
		var len = data.length;
		var h = Math.max(max - min, 1);
		var points = '0,' + HEIGHT;
		for (var i = 0; i < len; i++) {
			var y = HEIGHT - Math.floor(HEIGHT * (data[i] - min) / h);
			var x = i * WIDTH / (len - 1);
			points += ' ' + x + ',' + y;
		}
		points += ' ' + WIDTH + ',' + HEIGHT;
		state.line[k].setAttribute('points', points);
		state.line[k].style.visibility = 'visible';
	}

	state.label_25.firstChild.data = (0.25 * (max - min)).toFixed(2);
	state.label_50.firstChild.data = (0.50 * (max - min)).toFixed(2);
	state.label_75.firstChild.data = (0.75 * (max - min)).toFixed(2);
	state.graph_name.firstChild.data = state.graphAnnot;
}

/*
 * Field description
 */

function formatfix(n) { return function (x) { return x.toFixed(n); }; }
function formatyesno(v) { return v ? "yes" : "no"; }

var fieldsSummary = [
	{
		key: 'Hashrate1m',
		name: 'Gh/s 1m',
		graph: true,
		desc: 'Average hashrate, 1 minute window',
		unit: 1e6,
		format: formatfix(2),
	},
	{
		key: 'Hashrate15m',
		name: 'Gh/s 15m',
		graph: true,
		desc: 'Average hashrate, 15 minute window',
		unit: 1e6,
		format: formatfix(2),
	},
	{
		key: 'Hashrate24h',
		name: 'Gh/s 24h',
		graph: true,
		desc: 'Average hashrate, 24 hour window',
		unit: 1e6,
		format: formatfix(2),
	},
	{
		key: 'Found Blocks',
		graph: true,
	},
	{
		key: 'Accepted',
		graph: true,
	},
	{
		key: 'Rejected',
		graph: true,
	},
	{
		key: 'Hardware Errors',
		name: 'HW err',
		desc: 'Hardware Errors',
		graph: true,
	},
	{
		key: 'Work Utility',
		graph: true,
		format: formatfix(0),
	},
];
var fieldsPool = [
	{
		key: 'id',
		name: 'Pool ID',
	},
	{
		key: 'URL',
	},
	{
		key: 'User',
	},
	{
		key: 'Status',
	},
	{
		key: 'Accepted',
		graph: true,
	},
	{
		key: 'Rejected',
		graph: true,
	},
/*
	{
		key: 'Discarded',
		graph: true,
	},
*/
	{
		key: 'Stale',
		graph: true,
	},
	{
		key: 'LastDiff',
		graph: true,
		format: formatfix(0),
	},
	{
		key: 'Asic Boost',
		format: formatyesno,
	},
];
var fieldsChainCgminer = [
	{
		key: 'ID',
		name: 'Chain ID',
	},
	{
		key: 'MHS 5s',
		name: 'Real Rate',
		desc: 'Hashrate computed from submitted shares in Th/s (5s)',
		graph: true,
		format: function (x) { return (x/1000).toFixed(2); },
	},
	{
		key: 'maximal MHS',
		name: 'Maximal Rate',
		desc: 'Theoretical hashrate with current number of cores in Th/s',
		format: function (x) { return (x/1000).toFixed(2); },
	},
/*
	{
		key: 'voltage',
		name: 'Voltage',
	},
	{
		key: 'frequency',
		name: 'Frequency',
	},
*/
	{
		key: 'TempAVG',
		name: 'Temp avg.',
		graph: true,
		format: formatfix(1),
	},
	{
		key: 'TempMIN',
		name: 'Temp min.',
		graph: true,
		format: formatfix(1),
	},
	{
		key: 'TempMAX',
		name: 'Temp max.',
		graph: true,
		format: formatfix(1),
	},
	{
		key: 'CHIP',
		name: 'ASIC#',
		desc: 'Number of ASIC chips on chain',
	},
	{
		key: 'CORE',
		name: 'CORE#',
		desc: 'Number of cores on chain',
	},
	{
		key: 'Hardware Errors',
		name: 'HWerr',
		desc: 'Absolute number of hardware errors since miner started',
		graph: true,
	},
	{
		key: 'Hardware Error Rate',
		name: 'HWerr/h',
		desc: 'Average number of hardware errors per hour',
		graph: true,
		format: formatfix(1),
	},
];
var fieldsChainBmminer = [
	{
		key: 'ID',
		name: 'Chain ID',
	},
	{
		key: 'ratereal',
		name: 'Real Rate',
		desc: 'Hashrate computed from submitted shares',
		graph: true,
	},
	{
		key: 'ratechip',
		name: 'Chip Rate',
		desc: 'Hashrate reported by chips',
		graph: true,
	},
	{
		key: 'rateideal',
		name: 'Ideal Rate',
		desc: 'Theoretical hashrate at this frequency',
	},
	{
		key: 'voltage',
		name: 'Voltage',
	},
	{
		key: 'frequency',
		name: 'Frequency',
	},
	{
		key: 'temp1',
		name: 'Temp 1',
		graph: true,
	},
	{
		key: 'temp2',
		name: 'Temp 2',
		graph: true,
	},
	{
		key: 'cores',
		name: 'ASIC#',
		desc: 'Number of ASIC chips on chain',
	},
	{
		key: 'hwerrors',
		name: 'HWerr',
		desc: 'Absolute number of hardware errors since miner started',
		graph: true,
	},
	{
		key: 'hwerrorsrate',
		name: 'HWerr/h',
		desc: 'Average number of hardware errors per hour',
		graph: true,
		format: function (x) { return x.toFixed(1); },
	},
];
var fieldsFan = [
	{
		key: 'id',
		name: 'Fan ID',
	},
	{
		key: 'rpm',
		name: 'RPM',
		desc: 'Revolutions Per Minute',
		graph: true,
	},
];

/* Each dictionary defines one "table". The keys mean the following:

   elementId:	ID of HTML table element
   keys:	list of keys to show (in the JSON request)
   datasetKeys:	list of keys to graph (constant values like voltage does not
		make sense to graph
   prefix:	HTML ID prefix string (% gets replaced by index of table
		entry)
   nrowsGet	function that returns number of rows in table
   rowsGet	function that returns row by index
   subIds	Indexes of rows that are shown when the column heading is
		clicked. Absence of this function means: heading not
		clickable.
*/

var tables = [
	{
		elementId: 'chains-table',
		getFields: function (data) {
			return { bmminer: fieldsChainBmminer, cgminer: fieldsChainCgminer }[data.type];
		},
		prefix: 'chain%',
		nrowsGet: function (data) { return data.chains.length; },
		rowGet: function (data, i) { return data.chains[i]; },
		subIds: function (data, key) {
			if (key == 'ratereal')
				return [];
			return range(0, data.chains.length - 1);
		},
		getRowName: function (data, i) {
			if (i == data.chains.length - 1)
				return 'aggregated';
			else
				return 'chain ' + data.chains[i].ID;
		},
	},
	{
		elementId: 'pools-table',
		getFields: function (data) { return fieldsPool; },
		prefix: 'pool%',
		nrowsGet: function (data) { return data.pools.length; },
		rowGet: function (data, i) { return data.pools[i]; },
		subIds: function (data, k) { return range(0, data.pools.length); },
		getRowName: function (data, i) { return 'pool ' + data.pools[i].id; },
	},
	{
		elementId: 'summary-table',
		getFields: function (data) { return fieldsSummary; },
		prefix: 'stat',
		nrowsGet: function (data) { return 1; },
		rowGet: function (data, i) { return data.stats; },
	},
	{
		elementId: 'fans-table',
		getFields: function (data) { return fieldsFan; },
		prefix: 'fan%',
		nrowsGet: function (data) { return data.fans.length; },
		rowGet: function (data, i) { return data.fans[i]; },
		subIds: function (data, k) { return range(0, data.fans.length); },
		getRowName: function (data, i) { return 'fan ' + data.fans[i].id; },
		onlyFor: 'bmminer',
	},

];

function getName(field)
{
	return field.name || field.key;
}

function makeId(prefix, key, id)
{
	return prefix.replace('%', id) + '_' + key.replace(' ', '_');
}

function changeOnclickGen(state, graphIds, annot)
{
	if (graphIds.length == 0)
		return null;
	return function () {
		switchToGraphs(state, graphIds, annot);
		return false;
	}
}

function getAnnotation(def, data, field, ids)
{
	var annot = getName(field);
	if (def.getRowName) {
		var rows = ids.map(
			function (i) { return def.getRowName(data, i); }
		);
		annot += ' (' + rows.join(', ') + ')';
	}
	return annot;
}

function buildTable(state, def, data)
{
	var table = document.getElementById(def.elementId);
	var th = def.getFields(data).map(function (field) {
		var name = getName(field);
		if (field.graph && def.subIds) {
			var ids = def.subIds(data, field.key).map(
				function (i) { return makeId(def.prefix, field.key, i); }
			);
			var annot = getAnnotation(def, data, field, def.subIds(data, field.key));
			return makeDataCell('th', null, name,
				changeOnclickGen(state, ids, annot),
				field.desc || name);
		} else {
			return makeDataCell('th', null, name, null, field.desc);
		}
	});
	var rows = [th];
	for (var i = 0; i < def.nrowsGet(data); i++) {
		var row = def.getFields(data).map(function (field) {
			var annot = getAnnotation(def, data, field, [i]);
			var id = makeId(def.prefix, field.key, i);
			var clickFn = null;
			if (field.graph) {
				clickFn = changeOnclickGen(state, [id], annot);
				state.datasets[id] = new Dataset(SAMPLING_FREQ, KEEP_HISTORY_SEC);
			}
			return makeDataCell('td', id, '-', clickFn);
		});
		rows.push(row);
	}
	rows.forEach(
		function (row) { return table.appendChild(makeRow(row)); }
	);
}

function updateTable(state, def, data)
{
	for (var i = 0; i < def.nrowsGet(data); i++) {
		var row = def.rowGet(data, i);
		def.getFields(data).forEach(function (field) {
			var id = makeId(def.prefix, field.key, i);
			var val = row[field.key];
			var show = val;
			if (field.format)
				show = field.format(show);
			setId(id, show);
			if (field.graph) {
				state.datasets[id].push(val);
			}
		});
	}
}

function isTableOk(data, def)
{
	return !def.onlyFor || def.onlyFor == data.type;
}

function updateTables(state, data)
{
	if (!state.datasetsReady) {
		tables.forEach(
			function (x) {
				if (isTableOk(data, x))
					buildTable(state, x, data);
			}
		);
		state.datasetsReady= true;
	}
	tables.forEach(
		function (x) {
			if (isTableOk(data, x))
				updateTable(state, x, data);
		}
	);
}

function updateTablesNoData(state, isDead)
{
	for (id in state.datasets) {
		if (isDead)
			state.datasets[id].push(0);
		else
			state.datasets[id].pushLast();
	}
}

function doRequest(state)
{
	var xhr = new XMLHttpRequest();
	var url = location.protocol + '//' + location.host + ':' + API_PORT + '/stats+pools+summary+devs';
	xhr.open('GET', url, true);

	xhr.timeout = PAGE_TICK_DURATION_MS * 0.9;
	xhr.onreadystatechange = function() {
		if (xhr.readyState == 4) {
			try {
				state.json = eval('(' + xhr.responseText + ')');
			} catch(e) {
				state.json = null;
			};
		}
	};
	xhr.ontimeout = function() {
		console.log("timeout");
	};
	xhr.send(null);
}

function redrawGraphs(state)
{
	if (!state.datasetsReady)
		return;

	drawGraphs(state, state.currentGraphs.map(
		function (id) { return state.datasets[id].getBundle(DRAW_HISTORY_SEC); }
	));
}

function switchToGraphs(state, graphNames, annot)
{
	console.log('change to', graphNames);
	state.currentGraphs = graphNames;
	state.graphAnnot = annot;
	setId('what', ': '+ annot);
	redrawGraphs(state);
}

function runPageTick(state)
{
	/* process current request */
	if (state.json) {
		var data = transcribeApi(state.json);
		updateTables(state, data);
		state.deadForMs = 0;
		setId('status', 'OK');
	} else {
		state.deadForMs += PAGE_TICK_DURATION_MS;
		var dead = state.deadForMs >= PAGE_DEAD_TIMEOUT_MS;

		updateTablesNoData(state, dead);
		setId('status', dead ? "Can't connect to miner" : 'Stalled');
	}

	/* clear state */
	state.json = null;

	/* make new request */
	doRequest(state);
	redrawGraphs(state);
}

function initPage(svg, svgDoc)
{
	var globalState = {
		json: null,
		line: [],
		datasets: {},
		deadForMs: PAGE_DEAD_TIMEOUT_MS,
		svg: svg,
		svgDoc: svgDoc,
		currentGraphs: ['stat_Hashrate1m'],
		graphAnnot: 'Hashrate',
	};

	initGraph(globalState);

	var sched = new Scheduler(
		function () { return runPageTick(globalState); },
		PAGE_TICK_DURATION_MS
	);
	sched.run();
}

function waitForSvg(id, callback)
{
	var svg = document.getElementById(id);
	var svgDoc;
        try {
            svgDoc = svg.getSVGDocument
                ? svg.getSVGDocument() : svg.contentDocument;
        } catch(e) {
            svgDoc = document.embeds[id].getSVGDocument();
        }
	if (!svgDoc) {
		console.log('svg not there, waiting...');
		setTimeout(waitForSvg, 500, id, callback);
	} else {
		callback(svg, svgDoc);
	}
}

waitForSvg('hashrate-svg', initPage);

//]]></script>

<div style="text-align:right"><small id="scale"></small></div>
<br />

<%+footer%>
